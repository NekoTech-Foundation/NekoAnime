(function(){"use strict";var ae=typeof globalThis!="undefined"?globalThis:typeof window!="undefined"?window:typeof global!="undefined"?global:typeof self!="undefined"?self:{},F={exports:{}};const ie=e=>typeof crypto!="undefined"&&typeof crypto.getRandomValues=="function"?()=>{const r=crypto.getRandomValues(new Uint8Array(1))[0];return(r>=e?r%e:r).toString(e)}:()=>Math.floor(Math.random()*e).toString(e),K=(e=7,r=!1)=>Array.from({length:e},ie(r?16:36)).join("");F.exports=K,F.exports.default=K;var j=F.exports,ge=()=>`uid::${j(7)}`,me=(e,r=["endpointName","fingerprint"])=>typeof e=="object"&&e!==null&&r.every(s=>s in e),le=e=>{if(!me(e))throw new TypeError("Invalid connection args");return JSON.stringify(e)},ce=()=>{let e=[];return{add:(...r)=>{e=[...e,...r]},remove:r=>{e=typeof r=="string"?e.filter(s=>s.message.transactionId!==r):e.filter(s=>!r.includes(s))},entries:()=>e}},$=class{static toBackground(e,r){return e.postMessage(r)}static toExtensionContext(e,r){return e.postMessage(r)}},Q={exports:{}};(function(e,r){(function(s,i){i(e)})(typeof globalThis!="undefined"?globalThis:typeof self!="undefined"?self:ae,function(s){if(typeof globalThis!="object"||typeof chrome!="object"||!chrome||!chrome.runtime||!chrome.runtime.id)throw new Error("This script should only be loaded in a browser extension.");if(typeof globalThis.browser=="undefined"||Object.getPrototypeOf(globalThis.browser)!==Object.prototype){const i="The message port closed before a response was received.",m="Returning a Promise is the preferred way to send a reply from an onMessage/onMessageExternal listener, as the sendResponse will be removed from the specs (See https://developer.mozilla.org/docs/Mozilla/Add-ons/WebExtensions/API/runtime/onMessage)",c=a=>{const t={alarms:{clear:{minArgs:0,maxArgs:1},clearAll:{minArgs:0,maxArgs:0},get:{minArgs:0,maxArgs:1},getAll:{minArgs:0,maxArgs:0}},bookmarks:{create:{minArgs:1,maxArgs:1},get:{minArgs:1,maxArgs:1},getChildren:{minArgs:1,maxArgs:1},getRecent:{minArgs:1,maxArgs:1},getSubTree:{minArgs:1,maxArgs:1},getTree:{minArgs:0,maxArgs:0},move:{minArgs:2,maxArgs:2},remove:{minArgs:1,maxArgs:1},removeTree:{minArgs:1,maxArgs:1},search:{minArgs:1,maxArgs:1},update:{minArgs:2,maxArgs:2}},browserAction:{disable:{minArgs:0,maxArgs:1,fallbackToNoCallback:!0},enable:{minArgs:0,maxArgs:1,fallbackToNoCallback:!0},getBadgeBackgroundColor:{minArgs:1,maxArgs:1},getBadgeText:{minArgs:1,maxArgs:1},getPopup:{minArgs:1,maxArgs:1},getTitle:{minArgs:1,maxArgs:1},openPopup:{minArgs:0,maxArgs:0},setBadgeBackgroundColor:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setBadgeText:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setIcon:{minArgs:1,maxArgs:1},setPopup:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setTitle:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0}},browsingData:{remove:{minArgs:2,maxArgs:2},removeCache:{minArgs:1,maxArgs:1},removeCookies:{minArgs:1,maxArgs:1},removeDownloads:{minArgs:1,maxArgs:1},removeFormData:{minArgs:1,maxArgs:1},removeHistory:{minArgs:1,maxArgs:1},removeLocalStorage:{minArgs:1,maxArgs:1},removePasswords:{minArgs:1,maxArgs:1},removePluginData:{minArgs:1,maxArgs:1},settings:{minArgs:0,maxArgs:0}},commands:{getAll:{minArgs:0,maxArgs:0}},contextMenus:{remove:{minArgs:1,maxArgs:1},removeAll:{minArgs:0,maxArgs:0},update:{minArgs:2,maxArgs:2}},cookies:{get:{minArgs:1,maxArgs:1},getAll:{minArgs:1,maxArgs:1},getAllCookieStores:{minArgs:0,maxArgs:0},remove:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}},devtools:{inspectedWindow:{eval:{minArgs:1,maxArgs:2,singleCallbackArg:!1}},panels:{create:{minArgs:3,maxArgs:3,singleCallbackArg:!0},elements:{createSidebarPane:{minArgs:1,maxArgs:1}}}},downloads:{cancel:{minArgs:1,maxArgs:1},download:{minArgs:1,maxArgs:1},erase:{minArgs:1,maxArgs:1},getFileIcon:{minArgs:1,maxArgs:2},open:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},pause:{minArgs:1,maxArgs:1},removeFile:{minArgs:1,maxArgs:1},resume:{minArgs:1,maxArgs:1},search:{minArgs:1,maxArgs:1},show:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0}},extension:{isAllowedFileSchemeAccess:{minArgs:0,maxArgs:0},isAllowedIncognitoAccess:{minArgs:0,maxArgs:0}},history:{addUrl:{minArgs:1,maxArgs:1},deleteAll:{minArgs:0,maxArgs:0},deleteRange:{minArgs:1,maxArgs:1},deleteUrl:{minArgs:1,maxArgs:1},getVisits:{minArgs:1,maxArgs:1},search:{minArgs:1,maxArgs:1}},i18n:{detectLanguage:{minArgs:1,maxArgs:1},getAcceptLanguages:{minArgs:0,maxArgs:0}},identity:{launchWebAuthFlow:{minArgs:1,maxArgs:1}},idle:{queryState:{minArgs:1,maxArgs:1}},management:{get:{minArgs:1,maxArgs:1},getAll:{minArgs:0,maxArgs:0},getSelf:{minArgs:0,maxArgs:0},setEnabled:{minArgs:2,maxArgs:2},uninstallSelf:{minArgs:0,maxArgs:1}},notifications:{clear:{minArgs:1,maxArgs:1},create:{minArgs:1,maxArgs:2},getAll:{minArgs:0,maxArgs:0},getPermissionLevel:{minArgs:0,maxArgs:0},update:{minArgs:2,maxArgs:2}},pageAction:{getPopup:{minArgs:1,maxArgs:1},getTitle:{minArgs:1,maxArgs:1},hide:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setIcon:{minArgs:1,maxArgs:1},setPopup:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setTitle:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},show:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0}},permissions:{contains:{minArgs:1,maxArgs:1},getAll:{minArgs:0,maxArgs:0},remove:{minArgs:1,maxArgs:1},request:{minArgs:1,maxArgs:1}},runtime:{getBackgroundPage:{minArgs:0,maxArgs:0},getPlatformInfo:{minArgs:0,maxArgs:0},openOptionsPage:{minArgs:0,maxArgs:0},requestUpdateCheck:{minArgs:0,maxArgs:0},sendMessage:{minArgs:1,maxArgs:3},sendNativeMessage:{minArgs:2,maxArgs:2},setUninstallURL:{minArgs:1,maxArgs:1}},sessions:{getDevices:{minArgs:0,maxArgs:1},getRecentlyClosed:{minArgs:0,maxArgs:1},restore:{minArgs:0,maxArgs:1}},storage:{local:{clear:{minArgs:0,maxArgs:0},get:{minArgs:0,maxArgs:1},getBytesInUse:{minArgs:0,maxArgs:1},remove:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}},managed:{get:{minArgs:0,maxArgs:1},getBytesInUse:{minArgs:0,maxArgs:1}},sync:{clear:{minArgs:0,maxArgs:0},get:{minArgs:0,maxArgs:1},getBytesInUse:{minArgs:0,maxArgs:1},remove:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}}},tabs:{captureVisibleTab:{minArgs:0,maxArgs:2},create:{minArgs:1,maxArgs:1},detectLanguage:{minArgs:0,maxArgs:1},discard:{minArgs:0,maxArgs:1},duplicate:{minArgs:1,maxArgs:1},executeScript:{minArgs:1,maxArgs:2},get:{minArgs:1,maxArgs:1},getCurrent:{minArgs:0,maxArgs:0},getZoom:{minArgs:0,maxArgs:1},getZoomSettings:{minArgs:0,maxArgs:1},goBack:{minArgs:0,maxArgs:1},goForward:{minArgs:0,maxArgs:1},highlight:{minArgs:1,maxArgs:1},insertCSS:{minArgs:1,maxArgs:2},move:{minArgs:2,maxArgs:2},query:{minArgs:1,maxArgs:1},reload:{minArgs:0,maxArgs:2},remove:{minArgs:1,maxArgs:1},removeCSS:{minArgs:1,maxArgs:2},sendMessage:{minArgs:2,maxArgs:3},setZoom:{minArgs:1,maxArgs:2},setZoomSettings:{minArgs:1,maxArgs:2},update:{minArgs:1,maxArgs:2}},topSites:{get:{minArgs:0,maxArgs:0}},webNavigation:{getAllFrames:{minArgs:1,maxArgs:1},getFrame:{minArgs:1,maxArgs:1}},webRequest:{handlerBehaviorChanged:{minArgs:0,maxArgs:0}},windows:{create:{minArgs:0,maxArgs:1},get:{minArgs:1,maxArgs:2},getAll:{minArgs:0,maxArgs:1},getCurrent:{minArgs:0,maxArgs:1},getLastFocused:{minArgs:0,maxArgs:1},remove:{minArgs:1,maxArgs:1},update:{minArgs:2,maxArgs:2}}};if(Object.keys(t).length===0)throw new Error("api-metadata.json has not been included in browser-polyfill");class d extends WeakMap{constructor(o,A=void 0){super(A),this.createItem=o}get(o){return this.has(o)||this.set(o,this.createItem(o)),super.get(o)}}const g=n=>n&&typeof n=="object"&&typeof n.then=="function",p=(n,o)=>(...A)=>{a.runtime.lastError?n.reject(new Error(a.runtime.lastError.message)):o.singleCallbackArg||A.length<=1&&o.singleCallbackArg!==!1?n.resolve(A[0]):n.resolve(A)},f=n=>n==1?"argument":"arguments",y=(n,o)=>function(u,...w){if(w.length<o.minArgs)throw new Error(`Expected at least ${o.minArgs} ${f(o.minArgs)} for ${n}(), got ${w.length}`);if(w.length>o.maxArgs)throw new Error(`Expected at most ${o.maxArgs} ${f(o.maxArgs)} for ${n}(), got ${w.length}`);return new Promise((E,_)=>{if(o.fallbackToNoCallback)try{u[n](...w,p({resolve:E,reject:_},o))}catch(l){console.warn(`${n} API method doesn't seem to support the callback parameter, falling back to call it without a callback: `,l),u[n](...w),o.fallbackToNoCallback=!1,o.noCallback=!0,E()}else o.noCallback?(u[n](...w),E()):u[n](...w,p({resolve:E,reject:_},o))})},b=(n,o,A)=>new Proxy(o,{apply(u,w,E){return A.call(w,n,...E)}});let x=Function.call.bind(Object.prototype.hasOwnProperty);const M=(n,o={},A={})=>{let u=Object.create(null),w={has(_,l){return l in n||l in u},get(_,l,k){if(l in u)return u[l];if(!(l in n))return;let h=n[l];if(typeof h=="function")if(typeof o[l]=="function")h=b(n,n[l],o[l]);else if(x(A,l)){let C=y(l,A[l]);h=b(n,n[l],C)}else h=h.bind(n);else if(typeof h=="object"&&h!==null&&(x(o,l)||x(A,l)))h=M(h,o[l],A[l]);else if(x(A,"*"))h=M(h,o[l],A["*"]);else return Object.defineProperty(u,l,{configurable:!0,enumerable:!0,get(){return n[l]},set(C){n[l]=C}}),h;return u[l]=h,h},set(_,l,k,h){return l in u?u[l]=k:n[l]=k,!0},defineProperty(_,l,k){return Reflect.defineProperty(u,l,k)},deleteProperty(_,l){return Reflect.deleteProperty(u,l)}},E=Object.create(n);return new Proxy(E,w)},v=n=>({addListener(o,A,...u){o.addListener(n.get(A),...u)},hasListener(o,A){return o.hasListener(n.get(A))},removeListener(o,A){o.removeListener(n.get(A))}}),L=new d(n=>typeof n!="function"?n:function(A){const u=M(A,{},{getContent:{minArgs:0,maxArgs:0}});n(u)});let I=!1;const N=new d(n=>typeof n!="function"?n:function(A,u,w){let E=!1,_,l=new Promise(O=>{_=function(S){I||(console.warn(m,new Error().stack),I=!0),E=!0,O(S)}}),k;try{k=n(A,u,_)}catch(O){k=Promise.reject(O)}const h=k!==!0&&g(k);if(k!==!0&&!h&&!E)return!1;const C=O=>{O.then(S=>{w(S)},S=>{let H;S&&(S instanceof Error||typeof S.message=="string")?H=S.message:H="An unexpected error occurred",w({__mozWebExtensionPolyfillReject__:!0,message:H})}).catch(S=>{console.error("Failed to send onMessage rejected reply",S)})};return C(h?k:l),!0}),Be=({reject:n,resolve:o},A)=>{a.runtime.lastError?a.runtime.lastError.message===i?o():n(new Error(a.runtime.lastError.message)):A&&A.__mozWebExtensionPolyfillReject__?n(new Error(A.message)):o(A)},oe=(n,o,A,...u)=>{if(u.length<o.minArgs)throw new Error(`Expected at least ${o.minArgs} ${f(o.minArgs)} for ${n}(), got ${u.length}`);if(u.length>o.maxArgs)throw new Error(`Expected at most ${o.maxArgs} ${f(o.maxArgs)} for ${n}(), got ${u.length}`);return new Promise((w,E)=>{const _=Be.bind(null,{resolve:w,reject:E});u.push(_),A.sendMessage(...u)})},Le={devtools:{network:{onRequestFinished:v(L)}},runtime:{onMessage:v(N),onMessageExternal:v(N),sendMessage:oe.bind(null,"sendMessage",{minArgs:1,maxArgs:3})},tabs:{sendMessage:oe.bind(null,"sendMessage",{minArgs:2,maxArgs:3})}},G={clear:{minArgs:1,maxArgs:1},get:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}};return t.privacy={network:{"*":G},services:{"*":G},websites:{"*":G}},M(a,Le,t)};s.exports=c(chrome)}else s.exports=globalThis.browser})})(Q);var de=Q.exports,Ae=(e="")=>{const r=ge();let s,i=[];const m=ce(),c=new Set,a=new Set,t=(g,p)=>{switch(g.status){case"undeliverable":i.some(f=>f.message.messageID===g.message.messageID)||(i=[...i,{message:g.message,resolvedDestination:g.resolvedDestination}]);return;case"deliverable":i=i.reduce((f,y)=>y.resolvedDestination===g.deliverableTo?($.toBackground(p,{type:"deliver",message:y.message}),f):[...f,y],[]);return;case"delivered":g.receipt.message.messageType==="message"&&m.add(g.receipt);return;case"incoming":g.message.messageType==="reply"&&m.remove(g.message.messageID),c.forEach(f=>f(g.message,p));return;case"terminated":{const f=m.entries().filter(y=>g.fingerprint===y.to);m.remove(f),f.forEach(({message:y})=>a.forEach(b=>b(y)))}}},d=()=>{s=de.runtime.connect({name:le({endpointName:e,fingerprint:r})}),s.onMessage.addListener(t),s.onDisconnect.addListener(d),$.toBackground(s,{type:"sync",pendingResponses:m.entries(),pendingDeliveries:[...new Set(i.map(({resolvedDestination:g})=>g))]})};return d(),{onFailure(g){a.add(g)},onMessage(g){c.add(g)},postMessage(g){$.toBackground(s,{type:"deliver",message:g})}}},U,ue=(e,r,s)=>U!=null?U:U=new Promise(i=>{const m=a=>{const{data:{cmd:t,scope:d,context:g},ports:p}=a;if(t==="webext-port-offer"&&d===r&&g!==e)return window.removeEventListener("message",m),p[0].onmessage=s,p[0].postMessage("port-accepted"),i(p[0])},c=()=>{const a=new MessageChannel;a.port1.onmessage=t=>{if(t.data==="port-accepted")return window.removeEventListener("message",m),i(a.port1);s==null||s(t)},window.postMessage({cmd:"webext-port-offer",scope:r,context:e},"*",[a.port2])};window.addEventListener("message",m),e==="window"?setTimeout(c,0):c()}),fe=e=>{let r,s=!1,i,m;return{enable:()=>s=!0,onMessage:c=>i=c,postMessage:async c=>{if(e!=="content-script"&&e!=="window")throw new Error("Endpoint does not use postMessage");if(!s)throw new Error("Communication with window has not been allowed");return pe(r),(await m).postMessage(c)},setNamespace:c=>{if(r)throw new Error("Namespace once set cannot be changed");r=c,m=ue(e,c,({data:a})=>i==null?void 0:i(a))}}};function pe(e){if(typeof e!="string"||e.trim().length===0)throw new Error(`webext-bridge uses window.postMessage to talk with other "window"(s) for message routingwhich is global/conflicting operation in case there are other scripts using webext-bridge. Call Bridge#setNamespace(nsps) to isolate your app. Example: setNamespace('com.facebook.react-devtools'). Make sure to use same namespace across all your scripts whereever window.postMessage is likely to be used\``)}var xe=Object.defineProperty,be=Object.defineProperties,he=Object.getOwnPropertyDescriptors,Y=Object.getOwnPropertySymbols,we=Object.prototype.hasOwnProperty,ye=Object.prototype.propertyIsEnumerable,X=(e,r,s)=>r in e?xe(e,r,{enumerable:!0,configurable:!0,writable:!0,value:s}):e[r]=s,ee=(e,r)=>{for(var s in r||(r={}))we.call(r,s)&&X(e,s,r[s]);if(Y)for(var s of Y(r))ye.call(r,s)&&X(e,s,r[s]);return e},re=(e,r)=>be(e,he(r)),ve=/^((?:background$)|devtools|popup|options|content-script|window)(?:@(\d+)(?:\.(\d+))?)?$/,se=e=>{const[,r,s,i]=e.match(ve)||[];return{context:r,tabId:+s,frameId:i?+i:void 0}};const Ee=[{property:"name",enumerable:!1},{property:"message",enumerable:!1},{property:"stack",enumerable:!1},{property:"code",enumerable:!0}],W=Symbol(".toJSON was called"),_e=e=>{e[W]=!0;const r=e.toJSON();return delete e[W],r},te=({from:e,seen:r,to_:s,forceEnumerable:i,maxDepth:m,depth:c})=>{const a=s||(Array.isArray(e)?[]:{});if(r.push(e),c>=m)return a;if(typeof e.toJSON=="function"&&e[W]!==!0)return _e(e);for(const[t,d]of Object.entries(e)){if(typeof Buffer=="function"&&Buffer.isBuffer(d)){a[t]="[object Buffer]";continue}if(d!==null&&typeof d=="object"&&typeof d.pipe=="function"){a[t]="[object Stream]";continue}if(typeof d!="function"){if(!d||typeof d!="object"){a[t]=d;continue}if(!r.includes(e[t])){c++,a[t]=te({from:e[t],seen:[...r],forceEnumerable:i,maxDepth:m,depth:c});continue}a[t]="[Circular]"}}for(const{property:t,enumerable:d}of Ee)typeof e[t]=="string"&&Object.defineProperty(a,t,{value:e[t],enumerable:i?!0:d,configurable:!0,writable:!0});return a};function ke(e,r={}){const{maxDepth:s=Number.POSITIVE_INFINITY}=r;return typeof e=="object"&&e!==null?te({from:e,seen:[],forceEnumerable:!0,maxDepth:s,depth:0}):typeof e=="function"?`[Function: ${e.name||"anonymous"}]`:e}let ne=()=>({events:{},emit(e,...r){(this.events[e]||[]).forEach(s=>s(...r))},on(e,r){return(this.events[e]=this.events[e]||[]).push(r),()=>this.events[e]=(this.events[e]||[]).filter(s=>s!==r)}});var Me=(e,r,s)=>{const i=j(),m=new Map,c=new Map,a=t=>{if(t.destination.context===e&&!t.destination.frameId&&!t.destination.tabId){s==null||s(t);const{transactionId:d,messageID:g,messageType:p}=t,f=()=>{const b=m.get(d);if(b){const{err:x,data:M}=t;if(x){const v=x,L=self[v.name],I=new(typeof L=="function"?L:Error)(v.message);for(const N in v)I[N]=v[N];b.reject(I)}else b.resolve(M);m.delete(d)}},y=async()=>{let b,x,M=!1;try{const v=c.get(g);if(typeof v=="function")b=await v({sender:t.origin,id:g,data:t.data,timestamp:t.timestamp});else throw M=!0,new Error(`[webext-bridge] No handler registered in '${e}' to accept messages with id '${g}'`)}catch(v){x=v}finally{if(x&&(t.err=ke(x)),a(re(ee({},t),{messageType:"reply",data:b,origin:{context:e,tabId:null},destination:t.origin,hops:[]})),x&&!M)throw b}};switch(p){case"reply":return f();case"message":return y()}}return t.hops.push(`${e}::${i}`),r(t)};return{handleMessage:a,endTransaction:t=>{const d=m.get(t);d==null||d.reject("Transaction was ended before it could complete"),m.delete(t)},sendMessage:(t,d,g="background")=>{const p=typeof g=="string"?se(g):g,f="Bridge#sendMessage ->";if(!p.context)throw new TypeError(`${f} Destination must be any one of known destinations`);return new Promise((y,b)=>{const x={messageID:t,data:d,destination:p,messageType:"message",transactionId:j(),origin:{context:e,tabId:null},hops:[],timestamp:Date.now()};m.set(x.transactionId,{resolve:y,reject:b});try{a(x)}catch(M){m.delete(x.transactionId),b(M)}})},onMessage:(t,d)=>(c.set(t,d),()=>c.delete(t))}},T=class{constructor(e,r){this.endpointRuntime=e,this.streamInfo=r,this.emitter=ne(),this.isClosed=!1,this.handleStreamClose=()=>{this.isClosed||(this.isClosed=!0,this.emitter.emit("closed",!0),this.emitter.events={})},T.initDone||(e.onMessage("__crx_bridge_stream_transfer__",s=>{const{streamId:i,streamTransfer:m,action:c}=s.data,a=T.openStreams.get(i);a&&!a.isClosed&&(c==="transfer"&&a.emitter.emit("message",m),c==="close"&&(T.openStreams.delete(i),a.handleStreamClose()))}),T.initDone=!0),T.openStreams.set(this.streamInfo.streamId,this)}get info(){return this.streamInfo}send(e){if(this.isClosed)throw new Error("Attempting to send a message over closed stream. Use stream.onClose(<callback>) to keep an eye on stream status");this.endpointRuntime.sendMessage("__crx_bridge_stream_transfer__",{streamId:this.streamInfo.streamId,streamTransfer:e,action:"transfer"},this.streamInfo.endpoint)}close(e){e&&this.send(e),this.handleStreamClose(),this.endpointRuntime.sendMessage("__crx_bridge_stream_transfer__",{streamId:this.streamInfo.streamId,streamTransfer:null,action:"close"},this.streamInfo.endpoint)}onMessage(e){return this.getDisposable("message",e)}onClose(e){return this.getDisposable("closed",e)}getDisposable(e,r){const s=this.emitter.on(e,r);return Object.assign(s,{dispose:s,close:s})}},D=T;D.initDone=!1,D.openStreams=new Map;var Se=e=>{const r=new Map,s=new Map,i=ne();e.onMessage("__crx_bridge_stream_open__",a=>new Promise(t=>{const{sender:d,data:g}=a,{channel:p}=g;let f=!1,y=()=>{};const b=()=>{const x=s.get(p);typeof x=="function"?(x(new D(e,re(ee({},g),{endpoint:d}))),f&&y(),t(!0)):f||(f=!0,y=i.on("did-change-stream-callbacks",b))};b()}));async function m(a,t){if(r.has(a))throw new Error("webext-bridge: A Stream is already open at this channel");const d=typeof t=="string"?se(t):t,g={streamId:j(),channel:a,endpoint:d},p=new D(e,g);return p.onClose(()=>r.delete(a)),await e.sendMessage("__crx_bridge_stream_open__",g,d),r.set(a,p),p}function c(a,t){if(s.has(a))throw new Error("webext-bridge: This channel has already been claimed. Stream allows only one-on-one communication");s.set(a,t),i.emit("did-change-stream-callbacks")}return{openStream:m,onOpenStreamChannel:c}},q=fe("content-script"),J=Ae(),P=Me("content-script",e=>{e.destination.context==="window"?q.postMessage(e):J.postMessage(e)});q.onMessage(e=>{e.origin={context:"window",tabId:null},P.handleMessage(e)}),J.onMessage(P.handleMessage),J.onFailure(e=>{if(e.origin.context==="window"){q.postMessage({type:"error",transactionID:e.transactionId});return}P.endTransaction(e.transactionId)});var{sendMessage:R,onMessage:Fe}=P;Se(P);const Te="1.0.45",z=typeof navigator!="undefined"&&(navigator==null?void 0:navigator.userAgent.includes("Firefox")),Ce=typeof atob=="function",Pe=typeof Buffer=="function";typeof TextDecoder=="function"&&new TextDecoder,typeof TextEncoder=="function"&&new TextEncoder;const Ie="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",Ne=Array.prototype.slice.call(Ie),B=(e=>{let r={};return e.forEach((s,i)=>r[s]=i),r})(Ne),Oe=/^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/,V=String.fromCharCode.bind(String);typeof Uint8Array.from=="function"&&Uint8Array.from.bind(Uint8Array);const je=e=>e.replace(/[^A-Za-z0-9\+\/]/g,""),De=Ce?e=>atob(je(e)):Pe?e=>Buffer.from(e,"base64").toString("binary"):e=>{if(e=e.replace(/\s+/g,""),!Oe.test(e))throw new TypeError("malformed base64.");e+="==".slice(2-(e.length&3));let r,s="",i,m;for(let c=0;c<e.length;)r=B[e.charAt(c++)]<<18|B[e.charAt(c++)]<<12|(i=B[e.charAt(c++)])<<6|(m=B[e.charAt(c++)]),s+=i===64?V(r>>16&255):m===64?V(r>>16&255,r>>8&255):V(r>>16&255,r>>8&255,r&255);return s};function Re(e){const r=De(e),s=r.length,i=new Uint8Array(s);for(let m=0;m<s;m++)i[m]=r.charCodeAt(m);return i.buffer}const Z=z?e=>JSON.stringify(e):e=>e;document.addEventListener("http:request",async({detail:e})=>{document.dispatchEvent(new CustomEvent("http:response",{detail:Z(await R("http:request",e.req).then(r=>{switch(e.req.responseType){case"arraybuffer":r.data=z?r.data:Re(r.data);break;case"json":r.data=JSON.parse(r.data);break}return{id:e.id,isBuffer:z&&e.req.responseType==="arraybuffer",ok:!0,res:r}}).catch(r=>({id:e.id,ok:!1,res:r})))}))}),document.addEventListener("http:aborted",({detail:{signalId:e}})=>{R("http:aborted",{signalId:e})}),document.addEventListener("tabs",async({detail:e})=>{document.dispatchEvent(new CustomEvent("tabs:response",{detail:Z(await R("tabs",e).then(r=>({id:e.id,ok:!0,res:r})).catch(r=>({id:e.id,ok:!1,res:r})))}))}),document.addEventListener("set:referrers",async({detail:e})=>{await R("set:referrers",e.referrers),document.dispatchEvent(new CustomEvent("res:set:referrers",{detail:Z({id:e.id})}))}),document.documentElement.dataset.httpVersion=Te,document.documentElement.dataset.httpAllow=JSON.stringify(!0),document.documentElement.dataset.tabsApi=JSON.stringify(!0),document.documentElement.dataset.customReferer=JSON.stringify(!0)})();
